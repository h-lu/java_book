## 2.4 对象的“行为”：方法的力量 {#sec-oop-methods}

> “知行合一。”

到目前为止，我们的`Pet`对象已经有了自己的“属性”（名字、品种、年龄），并且通过构造方法和封装，保证了这些数据的安全与完整。

但一个真正的实体，不仅“是什么”（属性），更在于它“能做什么”（行为）。在Java中，对象的行为是通过 **方法 (Methods)** 来定义的。

我们现在打印一只宠物的信息，是在`Clinic`类里这样做的：
`System.out.println(dog1.getName() + "是一只" + dog1.getAge() + "岁的" + dog1.getBreed());`

这就像是诊所的护士拿着宠物的资料卡，自己读出来一样。但我们能不能让宠物“自己介绍”自己呢？让我们向AI提出这个需求。

::: {.callout-note title="与AI的对话：为对象添加行为"}

**你**：你好AI，我不想总是在`Clinic`类里拼接字符串来打印宠物信息。我能不能让`Pet`对象自己提供一个完整的介绍？

**AI助手**：这是一个巨大的思维转变，恭喜你！你正从“操作数据”转向“与对象交互”。这正是面向对象编程的精髓。要实现这个功能，我们需要给`Pet`类添加它自己的**行为**，也就是**方法**。

**你**：方法？听起来不错，怎么做？

**AI助手**：方法就是定义在类里面、可以被对象调用的“技能”或“动作”。我们来给`Pet`类添加一个名为`getProfile()`（获取简介）的方法。

```java
// Pet.java

public class Pet {
    private String name;
    private String breed;
    private int age;

    // ... (构造方法, getters, setters 保持不变) ...

    // 这就是我们定义的方法
    // public: 访问权限，公开的
    // String: 返回类型，表示这个方法会返回一个字符串结果
    // getProfile: 方法名
    // (): 参数列表，这里为空，表示执行这个动作不需要外部提供额外信息
    public String getProfile() {
        // 方法内部可以自由访问同一个对象的私有属性
        return "你好，我是" + this.name + "，一只" + this.age + "岁的" + this.breed + "。";
    }
}
```
**你**：我明白了！`getProfile()`就像是`Pet`对象的一个内置技能。那我怎么调用它呢？

**AI助手**：非常简单，在`Clinic`里，你只需要“命令”你的`Pet`对象去执行这个技能就行了：

```java
// 在 Clinic.java 的 main 方法中
Pet dog1 = new Pet("旺财", "中华田园犬", 3);

// 命令 dog1 对象调用它的 getProfile() 方法
String dog1Profile = dog1.getProfile();

// 打印方法返回的结果
System.out.println(dog1Profile); 
// 输出: 你好，我是旺财，一只3岁的中华田园犬。
```
看，现在`Clinic`类不再关心简介是如何生成的，它只管向`Pet`对象索要结果。这就是**封装行为**。如果未来你想改变介绍的格式，只需要修改`Pet`类里的`getProfile`方法，所有调用它的地方都无需改动。

**你**：那方法和我们之前学的构造方法有什么区别？

**AI助手**：很好的问题！它们很像，但有两个核心区别：
1.  **目的不同**：构造方法是为了“初始化对象”（给属性赋值），而普通方法是为了定义对象的“其他行为”。
2.  **调用方式不同**：构造方法在`new`的时候被系统自动调用，且只能调用一次；普通方法由我们通过`.`手动调用，可以调用任意多次。
:::

### 概念提炼：方法

*   **方法 (Method)**：定义在类中的、可被对象调用的“行为”或“动作”。它封装了操作对象数据的逻辑。
*   **方法签名**：包括访问修饰符（如`public`）、返回类型（如`String`、`void`）、方法名和参数列表。
*   **封装行为**：将如何做一件事的逻辑（如拼接字符串）隐藏在方法内部，调用者只需关心方法能做什么，而无需关心它如何做。

现在，我们的`Pet`对象不仅有了数据，更有了自己的行为。它变得越来越像一个有生命的“实体”了。

---

### 动手练习

1.  **添加新行为**：和你的AI伙伴一起，为`Pet`类添加一个新的、无参数的`public`方法，名为 `makeSound()`，它应该返回一个`String`。
2.  **实现逻辑**：在这个方法内部，使用 `if-else` 语句检查 `this.breed`（品种）属性。
    *   如果品种中包含“犬”或“狗”字样，就返回 `"汪汪！"`。
    *   如果品种中包含“猫”字样，就返回 `"喵~"`。
    *   否则，返回 `"[一种好奇的声音]"`。
    *   **提示**：你可以向AI提问：“如何判断一个Java字符串是否包含另一个特定的子字符串？”
3.  **调用验证**：在`main`方法中，为你创建的每个`Pet`对象调用 `makeSound()` 方法，并打印返回的叫声，看看是否符合你的预期。 