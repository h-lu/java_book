## 2.2 数据保险箱：封装的艺术 {#sec-oop-encapsulation}

> “夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。” —— 诸葛亮

在上一节，我们成功地根据`Pet`模板（类）创建了`dog1`和`cat1`这两个具体的宠物（对象）。但我们留下了一个隐患：我们可以在`Clinic`（诊所）类中，随意地通过 `dog1.age = 5;` 这样的代码直接修改一只宠物的年龄。

这似乎不太对劲。如果有人不小心写了 `dog1.age = -1;`，一个负数的年龄，这在现实世界中是不可能的，但我们的程序却会接受这个错误的数据。

如何保护我们对象内部的数据，确保它的安全和有效呢？这就要引出面向对象三大支柱中的第一个——**封装 (Encapsulation)**。

::: {.callout-note title="与AI的对话：为你的数据上锁"}

**你**：你好AI，在我的宠物诊所项目里，我发现我可以直接在`Clinic`类里把一只宠物的年龄改成-1岁，这不合理。我怎样才能阻止这种不安全的操作？

**AI助手**：你提出了一个顶级程序员最关心的问题：**数据保护**。解决方案就是**封装**。我们可以把它想象成三个步骤：

1.  **上锁**：把 `Pet` 类里所有的数据都锁进“保险箱”，让外部无法直接访问。
2.  **开窗**：提供几个受控的“公共窗口”，用于读取和修改这些数据。
3.  **安检**：在“修改”数据的窗口上，设置“安检员”，检查传入的数据是否合法。

我们先来完成第一步：**上锁**。只需要在所有属性前加上 `private` 关键字。

```java
// Pet.java
public class Pet {
    private String name;
    private String breed;
    private int age;
}
```
修改后，你再去 `Clinic` 类里试试看 `dog1.age = 5;`，你会发现我立刻就会报错，告诉你无权访问。

**你**：数据确实被保护起来了，但我现在连读取它的名字都不行了。那我该怎么用这些数据呢？

**AI助手**：说得对！所以我们需要第二步：**开窗**。我们为外部提供一对公共的（`public`）方法，来分别**获取(get)**和**设置(set)**数据。这被称为 **Getter 和 Setter**。手动写很繁琐，你可以直接让我来做：

> “AI，请为Pet类的所有私有字段生成public的getter和setter方法。”

我会立刻为你生成好：
```java
// Pet.java (部分代码)
public class Pet {
    private String name;
    private String breed;
    private int age;

    // name属性的getter
    public String getName() {
        return this.name;
    }
    // name属性的setter
    public void setName(String name) {
        this.name = name;
    }
    
    // breed属性的getter/setter...
    // age属性的getter/setter...
}
```

**你**：太棒了！现在我可以用 `dog1.setName("大黄")` 来修改名字了。但那个-1岁年龄的问题怎么解决？

**AI助手**：这就是最关键的第三步：**安检**。我们可以在 `setAge` 这个“窗口”上，加上我们的检查逻辑！

```java
// 在 Pet.java 的 setAge 方法中
public void setAge(int age) {
    if (age > 0) { // 只有年龄大于0才是有效数据
        this.age = age;
    } else {
        System.out.println("无效的年龄值：" + age);
    }
}
```
现在再试试看 `dog1.setAge(-1);`，程序就不会接受这个错误的值，并且会给你一个清晰的提示。你成功地保护了你的数据！
:::

### 概念提炼：封装

*   **封装 (Encapsulation)**：OOP的三大特性之一。其核心思想是 **隐藏内部实现细节，仅暴露有限的公共接口**。
*   **`private`**：访问修饰符，表示一个成员（属性或方法）只能在其所在的类内部被访问。这是“上锁”。
*   **Getter/Setter**：一对公共方法，分别用于读取和写入私有属性的值。这是为外部开的、受控的“窗口”。它们是封装最常见的实现模式。

通过封装，我们的`Pet`类变得更加健壮、安全和独立，就像一个真正的“实体”。这就是专业代码与临时代码的巨大区别。

### 动手练习

1.  回到你上一节创建的 `Pet` 类。
2.  将 `name`, `breed`, 和 `age` 属性都声明为 `private`。
3.  向你的AI伙伴发出指令：“请为Pet类的所有私有字段生成public的getter和setter方法。”
4.  在`setAge`方法中，与AI讨论并增加一个检查逻辑：年龄不能小于0或大于30（对于大多数宠物来说这是一个合理的上限）。如果输入的年龄不在此范围内，就不进行赋值，并打印一条提示信息。
5.  在`main`方法中，尝试通过setter设置一个有效的年龄和一个无效的年龄（比如-2或50），观察程序的行为。 