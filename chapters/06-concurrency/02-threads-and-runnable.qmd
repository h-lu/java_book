## 6.2 并发的“分身术”：Thread 与 Runnable {#sec-concurrency-threads}

> “一个人走路，可能走得快；但一群人走路，可以走得更远。” —— 并发编程的协作精神

在上一节，我们被那漫长的9秒钟下载时间深深震撼。我们清醒地意识到，让一个“工人”（主线程）按顺序埋头苦干是多么低效。当他在等待下载电影时，宝贵的CPU资源完全被浪费了，而其他两个任务只能焦急地排队。

要打破这个僵局，唯一的办法就是学会“分身术”——雇佣更多的工人，让他们同时开工。在Java的世界里，这门“分身术”的核心就是 `Thread`（线程）与 `Runnable`（任务）的艺术。

::: {.callout-note title="与AI的对话：雇佣你的第一个“工人”"}

**你**：AI，我受够了那个9秒的程序！我想让下载电影、音乐和文档这三个任务**同时**进行。我该如何创建新的“工人”来帮我干活？

**AI助手**：你已经领悟到了并发的精髓！要实现这个目标，我们需要做两件事：
1.  **定义“工作内容”**：清晰地描述每个工人需要做什么。在Java中，我们用 `Runnable` 接口来封装一个任务。
2.  **创建“工人”并分配任务**：雇佣一个真正的工人，并将工作内容交给他。这个工人就是 `Thread` 类。

**你**：听起来很合理。那我们先来定义一个“下载电影”的任务吧。

**AI助手**：好的。一个 `Runnable` 就是一个"可运行"的任务。在Java中，最经典的方式是创建一个实现它的匿名内部类。你看，就像这样：

```java
// "下载电影"的任务清单
Runnable downloadMovieTask = new Runnable() {
    @Override
    public void run() {
        // 把耗时的操作放在这里
        downloadFile("电影.mp4");
    }
};
```
这里的 `run()` 方法，就是这个任务被执行时，工人具体要干的活。

**你**：这个写法感觉有点复杂。特别是对于这么简单的任务，有没有更简洁的方式？

**AI助手**：问得好！这正是现代Java的优雅之处。对于 `Runnable` 这种只有一个抽象方法的接口（我们称之为“函数式接口”），我们可以使用一种名为**Lambda表达式**的“语法糖”来极大地简化它：

```java
// 使用 Lambda 表达式定义同样的任务，是不是清爽多了？
Runnable downloadMovieTask = () -> downloadFile("电影.mp4");
```
`() -> ...` 的结构，你可以直接理解为“一个无参数的任务，其内容是...”。它和上面的写法在功能上是完全等价的。

**你**：酷！现在我有了任务清单，怎么把它交给一个新工人去执行呢？

**AI助手**：很简单，我们 `new` 一个 `Thread`（工人），然后把任务清单 `downloadMovieTask` 交给他。最后，也是最关键的一步，是对他喊一声“开工！” (`.start()`)。

```java
// 雇佣一个新工人，并把“下载电影”的任务派给他
Thread movieThread = new Thread(downloadMovieTask);

// 命令工人开始干活！
// 这会启动一个全新的线程，独立于我们的主线程
movieThread.start(); 

// 主线程发布完命令后，就可以立刻做别的事情了
System.out.println("主线程：下载电影的任务已经分派下去了，我不用等它了！");
```
运行一下看看效果？你会发现主线程的这句话会立刻打印出来，下载任务则在后台默默进行。

:::

### 核心概念提炼

刚刚的对话中，我们已经掌握了Java并发编程的“分身术”。让我们系统地梳理一下关键知识点：

1.  **分工：`Runnable` 与 `Thread`**
    *   **`Runnable` 是“任务清单”**：它定义了**要做什么**。它是一个功能接口，核心是 `run()` 方法，里面包含了我们希望在另一个线程中执行的代码。
    *   **`Thread` 是"工人"**：它定义了**谁来做**。`Thread` 对象是真正的工作单元，它拥有独立的执行路径。我们将 `Runnable` 任务交给 `Thread`，由它来启动和管理新线程的生命周期。

2.  **关键指令：`thread.start()` vs `thread.run()`**
    *   **`thread.start()`**：这才是**启动并发**的正确方式。它会请求Java虚拟机（JVM）分配一个新的线程，然后由这个**新线程**来调用我们任务的 `run()` 方法。主线程调用 `start()` 后会立即返回，继续执行自己的代码。
    *   **`thread.run()`**：这是一个普通的**方法调用**。如果你这么做，任务的 `run()` 方法依然是在**主线程**中执行的，程序会按顺序执行，完全失去了多线程的意义。这是新手最容易犯的错误！

3.  **语法糖：Lambda表达式的优雅**
    *   `() -> someMethod()` 是对 `new Runnable() { public void run() { someMethod(); } }` 的极简写法。
    *   在现代Java（尤其是并发和集合操作中），使用Lambda能让代码更简洁、更易读，是强烈推荐的风格。

### 动手实践与挑战

理论已经清晰，现在轮到你来亲自指挥，完成我们“多线程下载模拟器”的核心改造了。

**你的任务**：
将上一节的单线程下载代码，彻底改造成一个真正的多线程版本。

**与AI协同的步骤**：

1.  **提出你的目标**：向AI明确你的意图：“请帮我修改上一节的代码。我需要创建三个独立的线程，分别用于下载'电影.mp4'、'音乐.mp3'和'文档.pdf'，让它们同时开始。”
2.  **为每个文件创建任务和工人**：
    *   参照本节的例子，为“音乐”和“文档”也创建对应的 `Runnable` 任务（`downloadMusicTask`, `downloadDocTask`）。
    *   为这两个任务分别创建新的 `Thread` 工人（`musicThread`, `docThread`）。
3.  **集体开工**：一口气调用所有三个线程的 `.start()` 方法。
4.  **观察结果**：在启动所有线程后，让主线程打印总耗时。你会惊奇地发现，总时间不再是9秒，而是变成了大约3秒！
    *   可以向AI提问：“为什么总耗时约等于最长的那个任务的时间，而不是所有任务时间的总和？” 引导AI为你解释并发执行的效率优势。

完成这个挑战，你就真正掌握了并发编程赋予你的、最强大的能力——**利用等待时间，化串行为并行**。 