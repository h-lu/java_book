## 6.1 任务启动：感受速度的瓶颈 {#sec-concurrency-bottleneck}

> "世界上最遥远的距离，是网络延迟的等待。" —— 程序员的无奈

在之前的章节里，我们的代码几乎都是瞬间完成。但在真实世界中，程序的大部分时间都可能花在"等待"上——等待网络响应、等待文件读取、等待用户输入。当一个程序因为某个耗时任务而"卡住"时，用户体验会直线下降。

为了亲身感受这种瓶颈，我们将模拟一个最常见的耗时场景：下载文件。

::: {.callout-note title="与AI的对话：单线程下载的漫长等待"}

**你**：AI，我想写一个程序来模拟下载文件。你能帮我创建一个`downloadFile`方法吗？它接收一个文件名，然后假装花了3秒钟来下载它，下载完成后打印一条消息。

**AI助手**：当然。我们可以使用`Thread.sleep()`方法来让当前的执行线程暂停一段时间，从而模拟耗时操作。这个方法会抛出一个`InterruptedException`，所以我们需要按惯例用`try-catch`处理它。

```java
public static void downloadFile(String fileName) {
    System.out.println("开始下载：" + fileName);
    try {
        // 让当前线程休眠 3000 毫秒（即 3 秒）
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        // 在这个简单示例中，我们暂时忽略这个异常
        e.printStackTrace();
    }
    System.out.println(fileName + " 下载完成！");
}
```

**你**：很好。现在，请帮我写一个`main`方法，用它来顺序下载三个文件："电影.mp4"、"音乐.mp3"、"文档.pdf"，并计算一下总共花了多长时间。

**AI助手**：没问题。我们可以在开始前和结束后分别记录一下系统时间。

```java
public static void main(String[] args) {
    long startTime = System.currentTimeMillis(); // 记录开始时间

    downloadFile("电影.mp4");
    downloadFile("音乐.mp3");
    downloadFile("文档.pdf");

    long endTime = System.currentTimeMillis(); // 记录结束时间
    long duration = (endTime - startTime) / 1000;
    System.out.println("所有文件下载完毕，总耗时：" + duration + " 秒");
}
```

**你**：我运行了程序，结果真的是9秒！这也太慢了。在我等待下载电影的那3秒钟里，CPU明明可以去开始下载音乐的。我怎么样才能让这三个下载任务**"同时"**进行，就像我的浏览器或者下载软件那样？

**AI助手**：你问到了点子上！这正是"并发编程"要解决的核心问题。我们目前的程序只有一个"工人"（主线程），他必须严格地按顺序做完一件事才能做下一件。要实现"同时"下载，我们就必须雇佣更多的"工人"，让他们并行工作。在Java里，这些"工人"就叫做**线程 (Thread)**。

:::

### 任务分解

我们刚刚亲身体验了**单线程顺序执行**的效率瓶颈。为了打破这个瓶颈，我们的"多线程下载模拟器"项目需要攻克以下几个关键技术点：

1.  **什么是线程？** 我们需要理解程序中的"线程"与操作系统的"进程"之间是什么关系。
2.  **如何创建并启动一个新"工人"？** 我们需要学习Java中创建`Thread`对象和启动它的标准方法。
3.  **如何给"工人"分配任务？** 我们需要学习如何定义一个具体的"下载任务"，并把它交给一个新创建的线程去执行。

准备好了吗？让我们先从理解什么是"线程"开始，然后创建出我们的第一个"多线程工人"。

---

### 动手练习

1.  **创建模拟方法**：在一个新类中，创建一个名为 `simulateDownload` 的 `public static` 方法。它应该接收一个`String`类型的`fileName`作为参数。
2.  **实现耗时操作**：在方法内部，首先打印 "开始下载 [文件名]"。然后，与AI结对，使用 `Thread.sleep(2000)` 来暂停程序2秒钟（2000毫秒），并用`try-catch`块处理可能出现的`InterruptedException`。最后，打印 "[文件名] 下载完成！"。
3.  **顺序调用**：在`main`方法中，连续调用三次 `simulateDownload` 方法，传入不同的文件名（例如："电影.mp4", "音乐.mp3", "图片.jpg"）。
4.  **计算总耗时**：像AI在对话中演示的那样，在三次调用之前和之后，分别使用 `System.currentTimeMillis()` 来记录时间戳，并计算出总共花费了多少秒。打印出这个总耗时。
5.  **思考与观察**：观察你的输出。总耗时是否约等于6秒？思考一下，为什么会是这样？这为我们下一节学习多线程的必要性提供了最直观的感受。 